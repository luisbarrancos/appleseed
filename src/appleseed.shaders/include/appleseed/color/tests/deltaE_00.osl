
//
// Same version as in appleseed/color/as_color_transforms.h, but
// but using Lab colors directly.
//

float sqr(float x) { return x * x; }

float deltaE_CIEDE2000(
    color   reference_Lab,
    color   sampleval_Lab)
{
    float reference_L = reference_Lab[0];
    float reference_a = reference_Lab[1];
    float reference_b = reference_Lab[2];

    float sampleval_L = sampleval_Lab[0];
    float sampleval_a = sampleval_Lab[1];
    float sampleval_b = sampleval_Lab[2];


    float reference_C = hypot(reference_a, reference_b);
    float sampleval_C = hypot(sampleval_a, sampleval_b);

    float C_bar = (reference_C + sampleval_C) / 2;
    float C_7 = pow(C_bar, 7);

    // 25^7 = 6103515625, using value directly causes an integer overflow
    float C_7_sqrt = sqrt(pow(C_bar, 7) / (pow(C_bar,7) + pow(25, 7)));
    float G = (1.0 - C_7_sqrt) / 2;


    float reference_a_prime = reference_a * (1 + G);
    float sampleval_a_prime = sampleval_a * (1 + G);

    float reference_C_prime = hypot(reference_a_prime, reference_b);
    float sampleval_C_prime = hypot(sampleval_a_prime, sampleval_b);
    float delta_C_prime = sampleval_C_prime - reference_C_prime;

    float C_bar_prime = (reference_C_prime + sampleval_C_prime) / 2;

    float reference_h_prime, sampleval_h_prime;

    if (reference_a_prime == reference_b)
    {
        reference_h_prime = 0;
    }
    else
    {
        reference_h_prime = atan2(reference_b, reference_a_prime);
        reference_h_prime = mod(degrees(reference_h_prime), 360);
    }

    if (sampleval_a_prime == sampleval_b)
    {
        sampleval_h_prime = 0;
    }
    else
    {
        sampleval_h_prime = atan2(sampleval_b, sampleval_a_prime);
        sampleval_h_prime = mod(degrees(sampleval_h_prime), 360);
    }

    float abs_h_prime_diff = abs(reference_h_prime - sampleval_h_prime);
    float delta_h_prime;

    if (reference_C_prime == 0 || sampleval_C_prime == 0)
    {
        delta_h_prime = 0;
    }
    else if (abs_h_prime_diff <= 180)
    {
        delta_h_prime = sampleval_h_prime - reference_h_prime;
    }
    else
    {
        delta_h_prime = (sampleval_h_prime <= reference_h_prime)
            ? sampleval_h_prime - reference_h_prime + 360
            : sampleval_h_prime - reference_h_prime - 360;
    }

    float delta_H_prime = 2 * sin(radians(delta_h_prime / 2)) *
        sqrt(reference_C_prime * sampleval_C_prime);

    float H_bar_prime;

    if (reference_C_prime == 0 || sampleval_C_prime == 0)
    {
        H_bar_prime = reference_h_prime + sampleval_h_prime;
    }
    else if (abs_h_prime_diff <= 180)
    {
        H_bar_prime = (reference_h_prime + sampleval_h_prime) / 2;
    }
    else
    {
        H_bar_prime = (reference_h_prime + sampleval_h_prime < 360)
            ? (reference_h_prime + sampleval_h_prime + 360) / 2
            : (reference_h_prime + sampleval_h_prime - 360) / 2;
    }

    float T = 1.0 -
        0.17 * cos(radians(H_bar_prime - 30)) +
        0.24 * cos(radians(2 * H_bar_prime)) +
        0.32 * cos(radians(3 * H_bar_prime + 6)) -
        0.20 * cos(radians(4 * H_bar_prime - 63));

    float delta_L_prime = sampleval_L - reference_L;

    float L_bar = (reference_L + sampleval_L) / 2;

    float S_L = 1.0 + ((0.015 * sqr(L_bar - 50)) / sqrt(20 + sqr(L_bar - 50)));
    float S_C = 1.0 + 0.045 * C_bar_prime;
    float S_H = 1.0 + 0.015 * C_bar_prime * T;

    float delta_theta = 30.0 * exp(-sqr((H_bar_prime - 275) / 25));

    float C_bar_7 = pow(C_bar_prime, 7);

    float R_T = -2.0 * sqrt(C_bar_7 / (C_bar_7 + pow(25, 7))) *
        sin(radians(2 * delta_theta));


    // K_L = K_C = K_H = 1

    float deltaE_00 = sqrt(
        sqr(delta_L_prime / S_L) +
        sqr(delta_C_prime / S_C) +
        sqr(delta_H_prime / S_H) +
        R_T * (delta_C_prime / S_C) * (delta_H_prime / S_H));


    return deltaE_00;
}

surface deltaE_00(
    color reference_Lab = 0,
    color sampleval_Lab = 0,
    float dE = 0
    )
{
    float dE_00 = deltaE_CIEDE2000(reference_Lab, sampleval_Lab);

    printf( "Sharma 2004 data dE = %.04f,\tcomputed dE = %.04f\n",
            dE, dE_00);

    Ci = dE_00 * emission();
}

